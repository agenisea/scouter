/**
 * Markdown Writer Utility
 *
 * Principle Focus:
 * - Trust: Consistent, predictable output format
 * - Accessibility: Clear, readable markdown
 * - Delight: Well-formatted, polished documents
 */

import { writeFile, mkdir } from 'fs/promises'
import { join } from 'path'
import type {
  JobOpportunity,
  FitAnalysis,
  CoverLetterDraft,
  ExportInput,
  ExportOutput,
} from '@/lib/types'

/**
 * Write a single job's markdown file
 *
 * @param outputDir - Directory to write to
 * @param job - Job opportunity
 * @param analysis - Optional fit analysis
 * @param coverLetter - Optional cover letter
 * @returns Path to written file
 */
export async function writeJobMarkdown(
  outputDir: string,
  job: JobOpportunity,
  analysis?: FitAnalysis,
  coverLetter?: CoverLetterDraft
): Promise<string> {
  const date = new Date().toISOString().split('T')[0]
  const filename = `${date}_${sanitizeFilename(job.company)}_${sanitizeFilename(job.title)}.md`
  const filepath = join(outputDir, filename)

  const content = generateJobMarkdown(job, analysis, coverLetter)

  await mkdir(outputDir, { recursive: true })
  await writeFile(filepath, content, 'utf-8')

  return filepath
}

/**
 * Generate markdown content for a job
 */
function generateJobMarkdown(
  job: JobOpportunity,
  analysis?: FitAnalysis,
  coverLetter?: CoverLetterDraft
): string {
  const lines: string[] = []

  // Header
  lines.push(`# ${job.title} at ${job.company}`)
  lines.push('')

  // Job Details
  lines.push('## Job Details')
  lines.push('')
  lines.push(`- **Location**: ${job.location}`)
  lines.push(`- **Remote Status**: ${formatRemoteStatus(job.remoteStatus)}`)
  lines.push(`- **Source**: ${job.source}`)
  if (job.salaryRange) {
    lines.push(`- **Salary Range**: ${job.salaryRange}`)
  }
  if (job.postedDate) {
    lines.push(`- **Posted**: ${formatDate(job.postedDate)}`)
  }
  lines.push(`- **Apply**: [Application Link](${job.applicationUrl})`)
  lines.push('')

  // Fit Analysis
  if (analysis) {
    lines.push('## Fit Analysis')
    lines.push('')
    lines.push(`**Overall Score**: ${analysis.overallScore}% ${getScoreEmoji(analysis.overallScore)}`)
    lines.push('')

    if (analysis.summary) {
      lines.push(`> ${analysis.summary}`)
      lines.push('')
    }

    // Strengths
    if (analysis.strengths.length > 0) {
      lines.push('### Strengths')
      lines.push('')
      for (const strength of analysis.strengths) {
        lines.push(`- ${strength}`)
      }
      lines.push('')
    }

    // Concerns
    if (analysis.concerns.length > 0) {
      lines.push('### Concerns')
      lines.push('')
      for (const concern of analysis.concerns) {
        lines.push(`- ${concern}`)
      }
      lines.push('')
    }

    // Match Details
    lines.push('### Match Details')
    lines.push('')
    lines.push('| Category | Score | Details |')
    lines.push('|----------|-------|---------|')
    lines.push(
      `| Skills | ${analysis.skillsMatch.score}% | ${analysis.skillsMatch.rationale} |`
    )
    lines.push(
      `| Experience | ${analysis.experienceMatch.score}% | ${analysis.experienceMatch.rationale} |`
    )
    lines.push(
      `| Tech Stack | ${analysis.techStackMatch.score}% | ${analysis.techStackMatch.rationale} |`
    )
    lines.push(
      `| Seniority | ${analysis.seniorityFit.score}% | ${analysis.seniorityFit.rationale} |`
    )
    lines.push('')
  }

  // Job Description
  lines.push('## Job Description')
  lines.push('')
  lines.push(job.description)
  lines.push('')

  // Requirements
  if (job.requirements.length > 0) {
    lines.push('## Requirements')
    lines.push('')
    for (const req of job.requirements) {
      lines.push(`- ${req}`)
    }
    lines.push('')
  }

  // Tech Stack
  if (job.techStack.length > 0) {
    lines.push('## Tech Stack')
    lines.push('')
    lines.push(job.techStack.join(', '))
    lines.push('')
  }

  // Cover Letter
  if (coverLetter) {
    lines.push('## Cover Letter')
    lines.push('')
    lines.push(coverLetter.content)
    lines.push('')

    if (coverLetter.customizations.length > 0) {
      lines.push('### Customizations Made')
      lines.push('')
      for (const customization of coverLetter.customizations) {
        lines.push(`- ${customization}`)
      }
      lines.push('')
    }
  }

  // Footer
  lines.push('---')
  lines.push('')
  lines.push('*Generated by Scouter - AI-Powered Job Search Assistant*')
  lines.push(`*Retrieved: ${job.scrapedAt}*`)

  return lines.join('\n')
}

/**
 * Write a summary markdown file for all jobs
 *
 * @param outputDir - Directory to write to
 * @param jobs - All job opportunities
 * @param analyses - Map of job ID to analysis
 * @returns Path to summary file
 */
export async function writeSummaryMarkdown(
  outputDir: string,
  jobs: JobOpportunity[],
  analyses: Record<string, FitAnalysis>
): Promise<string> {
  const filepath = join(outputDir, 'SUMMARY.md')

  // Sort jobs by score
  const sortedJobs = [...jobs].sort((a, b) => {
    const scoreA = analyses[a.id]?.overallScore ?? 0
    const scoreB = analyses[b.id]?.overallScore ?? 0
    return scoreB - scoreA
  })

  const lines: string[] = []

  // Header
  lines.push('# Job Search Summary')
  lines.push('')
  lines.push(`**Generated**: ${new Date().toISOString()}`)
  lines.push(`**Total Jobs Found**: ${jobs.length}`)
  lines.push('')

  // Statistics
  const highFit = jobs.filter((j) => (analyses[j.id]?.overallScore ?? 0) >= 80).length
  const mediumFit = jobs.filter((j) => {
    const score = analyses[j.id]?.overallScore ?? 0
    return score >= 60 && score < 80
  }).length
  const lowFit = jobs.length - highFit - mediumFit

  lines.push('## Statistics')
  lines.push('')
  lines.push(`| Category | Count |`)
  lines.push(`|----------|-------|`)
  lines.push(`| High Fit (80+) | ${highFit} |`)
  lines.push(`| Medium Fit (60-79) | ${mediumFit} |`)
  lines.push(`| Low Fit (<60) | ${lowFit} |`)
  lines.push('')

  // Top Matches
  lines.push('## Top Matches')
  lines.push('')
  lines.push('| Score | Company | Role | Location | Source |')
  lines.push('|-------|---------|------|----------|--------|')

  for (const job of sortedJobs.slice(0, 15)) {
    const score = analyses[job.id]?.overallScore ?? '-'
    const scoreStr = typeof score === 'number' ? `${score}%` : score
    lines.push(
      `| ${scoreStr} | ${job.company} | ${job.title} | ${job.location} | ${job.source} |`
    )
  }
  lines.push('')

  // Full List
  if (jobs.length > 15) {
    lines.push('## All Jobs')
    lines.push('')
    lines.push('<details>')
    lines.push('<summary>Click to expand full list</summary>')
    lines.push('')
    lines.push('| Score | Company | Role | Location |')
    lines.push('|-------|---------|------|----------|')

    for (const job of sortedJobs) {
      const score = analyses[job.id]?.overallScore ?? '-'
      const scoreStr = typeof score === 'number' ? `${score}%` : score
      lines.push(`| ${scoreStr} | ${job.company} | ${job.title} | ${job.location} |`)
    }
    lines.push('')
    lines.push('</details>')
    lines.push('')
  }

  // Footer
  lines.push('---')
  lines.push('')
  lines.push('*Generated by Scouter - AI-Powered Job Search Assistant*')

  await mkdir(outputDir, { recursive: true })
  await writeFile(filepath, lines.join('\n'), 'utf-8')

  return filepath
}

/**
 * Export all jobs, analyses, and cover letters to markdown files
 *
 * @param input - Export input with all data
 * @returns Export output with file paths
 */
export async function exportToMarkdown(input: ExportInput): Promise<ExportOutput> {
  const { jobs, analyses, coverLetters, outputDir } = input
  const files: string[] = []

  // Write individual job files
  for (const job of jobs) {
    const analysis = analyses[job.id]
    const coverLetter = coverLetters[job.id]

    try {
      const filepath = await writeJobMarkdown(outputDir, job, analysis, coverLetter)
      files.push(filepath)
    } catch (error) {
      console.error(`[export] Failed to write ${job.id}:`, error)
    }
  }

  // Write summary file
  const summaryPath = await writeSummaryMarkdown(outputDir, jobs, analyses)
  files.push(summaryPath)

  return {
    success: true,
    files,
    summaryPath,
    count: files.length,
    outputDir,
  }
}

// =============================================================================
// Helper Functions
// =============================================================================

/**
 * Sanitize a string for use as a filename
 */
function sanitizeFilename(str: string): string {
  return str
    .replace(/[^a-zA-Z0-9\s-]/g, '')
    .replace(/\s+/g, '_')
    .substring(0, 50)
}

/**
 * Format remote status for display
 */
function formatRemoteStatus(status: string): string {
  const statusMap: Record<string, string> = {
    remote: 'Remote',
    hybrid: 'Hybrid',
    onsite: 'On-site',
    unknown: 'Not specified',
  }
  return statusMap[status] || status
}

/**
 * Format ISO date string for display
 */
function formatDate(isoDate: string): string {
  try {
    const date = new Date(isoDate)
    return date.toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
    })
  } catch {
    return isoDate
  }
}

/**
 * Get emoji for score visualization
 */
function getScoreEmoji(score: number): string {
  if (score >= 80) return ''
  if (score >= 60) return ''
  if (score >= 40) return ''
  return ''
}
